


stateless Widgets
1 스크린상에 존재만 할뿐 아무것도 하지않음
2 어떠한 실시간 데이터도 저장하지않음
3 상태 모양 을 유발시키는 value 값을 가지지 않음

Stataful Widgets
1 사용자 interface 에 따라 모양이 바뀜
2 data 를 받게 되두 모양이 바뀜

Flutter Widget tree
1 widget tree 구조 정리 할수 있음
2 한 widget 은 other widget  include   
3 widget  은  parent widget  자식 위젯
4 Parent widget 은 widget container 





APi





기본적으로 widget 에 입력 값은  named {parameter} 

funtion({var x})  =>named parameter 값 생략 가능하지면  입력시 x 는 얼마라고 지정해줘야한다
         미입력시 => null
         x:  반드시지정해야함 

funtion([var x = y]) =>optionnull parameter 다생략 가능 
             미입력시 =>y


BuildContext 는 widget tree 에서 현재  widget 위치를 알수 있는정보
build method 는 Scaffold 위젯을 리턴하는데  이때 어디에 위치하는 정보를 가진 
context 를 넣어서 리턴을 해준다 


플러터는 위젯(Widget)의 크기, 여백 등의 설정을 위해 컨테이너(Container) 개념을 
두고 있다. 컨테이너는 자식 위젯의 크기와 여백(Margine, Padding) 등을 설정한다.
 또한 컨테이너는 다시 부모 위젯으로 컬럼(Column)과 로우(Row)를 둘 수 있다. 
 개별 위젯을 조종하기 위해서는 먼저 
 ‘바디(Body) > 컬럼/로우 > 컨테이너 > 위젯(예:TextField, Button)’의 계층 구조를 갖음


child를 속성으로 가지는 위젯은 Center나 Container 등의 하나의 위젯만 들어가는 위젯이고
children를 속성으로 가지는 위젯은 복수의 위젯을 가질 수 있는 Row, Column, ListView, Stack 등이 있다.


 Drawer
Scaffold의 속성으로 줄 수 있습니다.
child로 ListView를 준 것을 보실 수 있는데 대개 Drawer에는 ListView를 사용합니다.
ListView의 children으로 DrawerHeader를 줘서 헤더를 구성하고 
그 아래로 ListTile을 붙여나가는 방식으로 처리합니다.

Container를 활용해서 각 원소들을 끝으로 밀어 넣을 수 있다.
 width 값을 double.infinity로 주면 된다.
해당 컨테이너는 길이, 높이가 없고 속성만 가졌으므로 'invisible Container'라고 불리운다.



Form 필드 내부에 위치했을 때의 validation이 가능한지입니다.

 

TextFormField는 속성으로 validator가 존재하지만 TextField는 존재하지 않습니다. 
아무 값이나 받으면 상관 없을 때 TextField를 사용하고 좀더 검증해야 하는 값에는 TextFormField를 사용하면됩니다

 

ListTile을 눌렀을 때는 보통 작동한 후 탭이 닫히는데 이는 Navigator.pop()으로 닫을 수 있습니다.

이 의미는 Drawer가 열린 것은 다른 화면 위에 쌓인 것으로 본다는 말입니다.





위젯의 key 값을 보고 싶으면 ctrl+space 한다
모든 widget은 MaterialApp child 가 되어야한다 push 는 context 는 

runApp
    MyApp                               // 스크린 레이아웃 을 최초로 빌드  뼈대를 만든다
    =>MaterialApp                     //title  String 사용  앱을 총칭하는이름  
            title:                             최근 사용한 앱 리스트 볼때 나오는 이름 
            theme: ThemeData(primaryColor: Colors.x) //  앱바의 태마를 선택한다
            home : MyHomePage(임의의 widget 입력 Scaffold 도가능)
                    =>Scaffold
                        appbar: AppBar              // title  Text widget  사용  그냥 앱바에나오는이름
                                    title:Text 
                        body:  Center
                                    L Column
                                    L widget

    custom widget 만들땐 stl 인지 stf 인지 고심해야함 



return MaterialApp(
    debugShowCheckedModeBanner: false  // 디버그 표시를 지워준다  최상위 에서 선택
)


Scaffold(
    backgroundColor:Colors.amber[숫자];  // 전체의 호박색 백그라운드 다
                                            위치는 안에만 있으면 된다 AppBar 에서 설정 하지않는이상 
    
    
     drawer: Drawer(                                      //앱바의 햄버거 매뉴를 자동으로 생기고 누르면 나오는 자신의 상태창
                                                          //ctrl click Scaffold 속성
                                                           //drawer value 값은 위젯 이와야함
             child: ListView(                               //복수의 widget 이 나열할수있음 각각 ListTile 을 가지고있음
                        padding: EdgeInsets.zero,           // 여백을 없에버림
                            children: <Widget>[             //ListView 는 child 아 아닌 children 이온다
                                 UserAccountsDrawerHeader(   // 유저개정 정보가 보여야함
                                    currentAccountPicture: CircleAvatar(
                                        backgroundImage: AssetImage('assets/cat.png'),
                                        ),
                                    countName: Text('KKang'),             //@reqire 반드시써야함
                                    accountEmail: Text('kang@bb.com'),    //@reqire 반드시나와야함
                                    onDetailsPressed: () {                //기능을 수행한fuchtion 형태 와야함  
                           
                                     print('arrow is clicked');
                                     },
                                 otherAccountsPictures: <Widget>[       //복수 우측 끝에 위치한다
                                    CircleAvatar(
                                    backgroundImage: AssetImage('assets/bear.jpg'),
                                    backgroundColor: Colors.white,
                                    ),
                        decoration: BoxDecoration(                  
                                    color: Colors.red[200],
                                    borderRadius: BorderRadius.only(
                                        bottomLeft: Radius.circular(40.0),  //곡선율 40 설정
                                        bottomRight: Radius.circular(40.0),
                        ListTile(
                                leading: Icon(   // 왼쪽끝에 아이콘을 삽입
                                    Icons.home,
                                    color: Colors.grey[850],
                                    ),
                                title: Text('Home'),
                                onTap: () {                        // 길게누르기 두번 누르기 액션을 감지할수있음
                                    print('home is clicked');      // 스플레시 효과도 나옴
                                    },
                                trailing: Icon(Icons.add),     //오른쪽끝에 아이콘을 삽입 
                                     ),
        appBar:
        body: Builder(                         //스넥바 를 사용하기위해선 Scaffold.of(context)
                                               //하위트리 Builder 만든다 
            builder:(BuildContext ctx){        // Builder 에서 리턴된 값인 ctx  
                return Center(
                    child: FlatButton(
                        child:Text(
                            'show me',
                            style: TextStyle(            //버튼 스타일은 따로잡는다
                                color:Colors.white.
                            ),
                        ),
                    color:Colors.red,
                    onPressed:(){
                        Scaffold.of(ctx).showSnackBar(SnackBar(  //Scaffold 의 context 값 ctx 입력
                            content: Text('hello'),
                        ));
            
            body: MySnackBar(),             // 가독성으로 MySnackBar 함수만듬

        class MySnackBar extends StatelessWidget {
                @override
                Widget build(BuildContext context) {
                    return Center(
                    child: RaisedButton(
                        child: Text('show me'),
                        onPressed: () {
                            Scaffold.of(context).showSnackBar(
                            SnackBar(
                                content: Text(
                                'hellow',
                                textAlign: TextAlign.center,   //글자 정렬
                                style: TextStyle(color: Colors.white),
                                ),
                                backgroundColor: Colors.teal,
                                duration: Duration(milliseconds: 1000), //지연시간 1000 1초 



toast

import 'package:fluttertoast/fluttertoast.dart';  // 토스트 메시지 를 쓰기위해 콜


            body: Center(
                    child: FlatButton(
                    onPressed: () {
                      flutterToast();            //토스트 함수 호출 
                    child: Text('toast'),
                    color: Colors.blue,
             
            void flutterToast() {
                Fluttertoast.showToast(               //enum 값 
                msg: 'flutter',                      // 호출 메시지
                gravity: ToastGravity.BOTTOM,       // 호출 위치
                backgroundColor: Colors.redAccent,    //배경색
                fontSize: 20.0,
                textColor: Colors.white, 
                toastLength: Toast.LENGTH_SHORT);       //토스트 유지시간
           


safearea
            Scaffold(                             //Container 사용        
                backgroundColor: Colors.blue,
                body: SafeArea(       //컨테이너 가 화면 에 보이지않기때문에 safearea 이용 alt+ 엔터 사용
                    child: Container(   //child 가없을 경우 컨테이너는 최대한 공간에 포지션
                    child: Text('hello'),   // child 가지면 텍스트 크기로 변한다
                                            // Container 는 하나의 컨테이너를 같는다
                    color: Colors.red,
                    width: 100,
                    height: 100,
                    margin:EdgeInsets.symmetric(  // 마진값 수치를 임의적으로 변경할수 있다
                        vertical: 50,           //세로
                        horizontal: 10          //가로
                    ),
                        padding: EdgeInsets.all(20), // 상하좌우 수치값  andauto 에서 inspetor 에서 볼수있음 
                    ),


  Colum 심화                                             
        Scaffold(
                backgroundColor: Colors.teal,
                body: SafeArea(
                    //child: Center(// 센터위젯 세로통제권 없음
                    child: Column(
                        //mainAxisAlignment: MainAxisAlignment.center,//세로는 무한확장 가로는 크기가 제한됨
                        // mainAxisSize:MainAxisSize.min, //  센터위젯이 세로 통제권얻음
                        //verticalDirection: VerticalDirection.up, // 아래에서부터 컨테이너가 올라감
                        //verticalDirection: VerticalDirection.down, //위에서 아래로 내려감 defult 값같음
                        //mainAxisAlignment: MainAxisAlignment.spaceEvenly, // 컬럼숫자 사이를 같은간격으로 나누어짐 1번 컨네이너 위는 공백이생김
                        //mainAxisAlignment: MainAxisAlignment.spaceBetween, // 1번과 n 번 컬럼이 각자 구석을 차지 하며 너누어짐
                        //crossAxisAlignment: CrossAxisAlignment.end, // 가로축 끝 기준으로 정렬하라
                        //crossAxisAlignment: CrossAxisAlignment.start, // 가로축 끝 시작 기준으로 정렬 하라
                        //crossAxisAlignment: CrossAxisAlignment.stretch, // 가로축끝까지 영역을 넓여줌

                        children: <Widget>[
                        Container(
                            width: 100,
                            height: 100,
                            color: Colors.white,
                            child: Text('container 1'),
                        ),
                        Container(
                            width: 100,
                            height: 100,
                            color: Colors.blue,
                            child: Text('container 2'),
                        ),
                        Container(
                            width: 100,
                            height: 100,
                            color: Colors.red,
                            child: Text('container 3'),
                        ),
                        // Container(                 // 컨테이너는 세로 통제권이 없음 컨테이너 크기가 바로 세로 끝임
                        //                           // 화면 오른쪽 끝 기준으로 정령 할려면 새로운컨테이너 인비져블 컨테이너
                        //                           // 가필요함
                        //   width: double.infinity,
                        //   height: 20,
                        // )





appBar: AppBar(
        title: Text('BBANTO'),
        centerTitle: true,                  // 엡바 에서 텍스트 값을 센터로 놓고싶을때 boolren 
        backgroundColor: Colors.redAccent   // 엡바 백그라운드 칼러 설정 
        elevation: 0.0,                     //appbar 높이 설정
        
        leading: IconButton(               //leading AppBar IconButton( 왼쪽정렬 
            icon: Icon(Icons.menu),          // icon : Icon(Icons 햄버거 아이콘 선택
                onPressed: () {                  // 버튼에 사용  함수의 형태로 버튼을 눌렀을대 함수내용실행
                    print('menu cliced');
          },

        actions: <Widget>[                //actions Appbar 오른쪽정렬 1가지이상 추가할수록 처음은 밀린다
            IconButton(
                icon: Icon(Icons.shopping_cart),
            IconButton(
                icon: Icon(Icons.search),
            },
          ),

        body: Padding(
            
             padding:EdgeInsets.fromLTRB(left,top,right,bottom), //inset 뭔가를 삽입하다
            
            child: Column(                 
               
                crossAxisAlignment : CrossAxisAlignment.start, // 컬럼을 가로 왼쪽에서 시작한다
                mainAxisAlignment : MainAxisAlignment.center  //컬럼을 세로 가운데는 축을 정렬 뜻한다 
                     
                    children:<widget>[                     // column 은 child  오고 children Text 로 온다
                         
                         Center(
                             child: CircleAvatar(          //이미지 동그라미안에 넣은다
                             backgroundImage:AssetImage('assets/name') // assets 폴더를 만든후 이미지저장 
                                                                //pubspec.yaml 에 assets 가서 이미지 경로를 지정한다
                             radius: 동그라미 크기 
                             backgroundColor:Colors.x     //투명이미지 배경설정
                             )
                         ),

                         Divider(        // 가로 줄을 그어넣은다
                             height:     //위아래 포함이다
                             thickness:  //선의 두깨
                             endIndent   // 선이 끝나는 지점을 정한다
                         )


                         Text('String',                     //text 처음 파라미터는 스트링 문자열입력
                            letterSpacing:                  // 글자간격 소수점 1자리까지 찍어줌        

                         )
                     ]
                SizeBox(                                   //column 안에 세로 글간격을 조절한다
                    height:                                 //세로 cols
                    width:                                  //가로 rows
                )

                Row(
                    children:<Widget>[
                        Icon(Icons.check_circle_outline), // flutter 에서 제공하는 체크박스 이미지를 가저온다 
                                                            // 왼쪽에 미리보기 제공함

                    ]
                )
                                                               
            ) 
        
        body:Center(                 //center widget 이있다고해서 화면정중앙 배치되는거아님
            child: Column(             Column 위젯가 만나게 되면 왜냐면 column 은세로축 재약이 없기 때문이다
               mainAxisAlignment:MainAxisAlignment.center 
            )
        )
        )

//flutter 에서 route 는 하나의 page 이다
// navigator 는 route 를 stack data구조로 관리한다
// stack data구조는 쌓아올리는데 추가할땐 push method 제거할댄 Pop method
// 모든 route 는 MaterialApp 위젯 아레에 child 로 있어야한다

            class MyApp extends StatelessWidget {
            @override
            Widget build(BuildContext context) {
                return MaterialApp(
                home: FristPage(),                  // route 는 materialApp 아래에 위치해야한다
            
            class FristPage extends StatelessWidget {
            @override
            Widget build(BuildContext context2) {    
                return Scaffold(
                appBar: AppBar(
                    title: Text('frist page'),
                    centerTitle: true,
                    backgroundColor: Colors.blue,
                    
                body: Center(
                    child: RaisedButton(
                        child: Text('Go to the Second Page'),
                            onPressed: (){                                     //onPressed 뒤에는 함수가 와야함
                            Navigator.push(context2,                            //context 가 가지고있는 widget tree 위치정보 를 가지고 현제 route 를 확인하고 push 함수가 원하는 route 를 쌓아올려줘야한다  
                            MaterialPageRoute(builder:(context2)=>SecondPage()   //네비게이터는 push 와 pop 으로 stack 으로 정리하는데
                                                                                //빌더 를 통해서 현제위치를 받아 원하는 route 로이동한다
                                                                                //SecondPage 는 FristPage 위로 올라가는거다

            class SecondPage extends StatelessWidget {
            @override
            Widget build(BuildContext ctx) {
                return Scaffold(
                appBar: AppBar(

                    title: Text('Second page'),
                    centerTitle: true,
                    backgroundColor: Colors.red,
                    elevation: 0.0,
                ),
                body: Center(
                    child: RaisedButton(
                    child: Text('Go to the Frist Page'),
                    onPressed: (){
                        Navigator.pop(ctx);              // 네비게이터 pop 은 단지 제거만 해준다 그러면  아래route 가 나오기때문이다



multipage  Navigator

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(          //routes 이동할 페이지 이름생성 map 자료형
      initialRoute: '/',      //multi page 시 선택 home 이랑 같이사용하지 않음
      routes: {              // flutter start page 는 보통 / 로지정함
         '/': (context) => ScreenA(), 
        '/b': (context) => ScreenB(),
        '/c': (context) => ScreenC(),

class ScreenA extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('ScreenA'),
        centerTitle: true,
      ),
      body: Center(

        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,  //center 와 column 이 같이올때 반드시써야함
          children:<Widget> [
            RaisedButton(
              color: Colors.red,
                onPressed:(){
                Navigator.pushNamed(context, '/b');
                },
                child: Text('go to ScreenB')
            ),
            RaisedButton(
                color: Colors.red,
                onPressed:(){
                Navigator.pushNamed(context, '/c');
                },
                child: Text('go to ScreenC')



List<String> number=new List(); //growable  <dynamic> 이것이 generic 
var number2=new List(5);  //fixed-length
            number.add(5);
            number.add('kk');
            number.add(4.2);
            number.add(addNumber(3,4));
            number.add(true);
            print(number); // 함수 나 블리언 까지 리스트 들어간다
            int addNumber(num1 , num2)=>num1+num2;

void main() {
        var number =List(); 
        number.add(5);
        printNumber(number); //number 는 dynamic 타입 리스트라 오류

void printNumber(List<int>a){ // int 타입 리스트 
print(a);

List<String> names=List();
names.addAll(['a','b','c']); //list 이기때문에 []써야함
print(names);





void main() {

        //   var ccS=new CircleSlot();
        
        //   Circle x = new Circle(); 
        //   ccS.insert(x); 
        
        //   ccS.insert(new Circle()); // 같다 ㅡ,.ㅡ
        
        
        //   var sqS=new SquareSlot();
        //   sqS.insert(new Circle());    

        // class SquareSlot{
        // insert(Square sq){
        // class CircleSlot{
        // insert(Circle cc){


Stataful 은 제너릭 기법을 이용한다

class Circle{}
class Square{}


var ccS=new Slot<Circle>();          //이것이 제너릭스 기법
  ccS.insert(new Circle());           // 다른 것이 추가되면 triangle 이라던가 
 var sqS=new Slot<Square>();
sqS.insert(new Square());            // 간결 하고 중복을 피하며 재사용성이 좋아야 좋은코드이다
                                        
class Slot<T>{                        //이것이 제너릭스 기법
insert(T shape){                        

   



void main()=>runApp(MyApp());

class MyApp extends StatefulWidget {
  @override
  State<StatefulWidget> createState() => MyAppState();

}
class MyAppState extends State<MyApp> {
  int _count=0;
  @override
  Widget build(BuildContext context) {  // build 메서드는 SLW과 SFW(더 정확히는 SFW의 State 클래스)에서 구현되며 화면을 구성할 UI들을 구현하는 메서드다
                                          //화면이 출력될 때 build 메서드가 호출되면서 build 메서드 내부에 구현한 UI 위젯들이 화면에 출력된
    print("** build - StatelessWidget Demo"); //SLW은 변화가 필요없는 화면을 구성할 때 사용하는 위젯 클래스이며, 그렇기 때문에 build 메서드는 한 번만 호출된다.


    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('Stateless Widget'),
          backgroundColor: Colors.blue,

        ),
        body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text(
              "$_count",
              style: TextStyle(
                fontSize: 30
              ),
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children:<Widget> [
                FloatingActionButton(
                  heroTag: null,
                    child: Icon(Icons.add),
                    onPressed:(){
                    setState(() {  //SFW 내부의 상태를 변경할 때 사용하는 메서드
                      _count++;
                      print("value of _count= $_count");
                    });


                    }),
                FloatingActionButton(
                  heroTag: null,
                    child: Icon(Icons.remove),
                    onPressed:(){
                    setState(() {  //setState 메서드에서 변경된 상태 값을 플랫폼에 전달하여 build 메서드가 호출
                      _count--;
                      print("value of _count= $_count");
                    });



class _LogInState extends State<LogIn> {  //alt enter stf 로 바꾼다
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Log in'),
        backgroundColor: Colors.redAccent,
        centerTitle: true,
        leading: IconButton(  // 앱바 좌측 정령
            icon: Icon(Icons.menu),
            onPressed: (){}
        ),
        actions: <Widget>[  //앱바 오른쪽 정령
          IconButton(
              icon: Icon(Icons.search),
              onPressed: (){}
          )
        ],
      ),
      body: SingleChildScrollView(  //자판기 사용시 화면이 밀릴경우 사용한다
        child: Column(  //전체적인 화면 구성을 크게 2개의 컬럼으로 구성
          
          children:<Widget> [
            Padding(padding: EdgeInsets.only(top: 50)), //상단에서 50px 떨어짐
            Center(  // 이미지로 상단을 구성 하고

              child: Image(
                image: AssetImage('image/chef.gif'),
                width:170 ,
                height: 190,
              ),
            ),
            Form( //하단은 폼 으로 잡고
              child:Theme(  // 폼의 형식을 설정함
                data: ThemeData(
                  primaryColor: Colors.orangeAccent,   //text 입력줄 아래 색 선택시 보여줌
                  inputDecorationTheme: InputDecorationTheme(
                    labelStyle: TextStyle(
                      color: Colors.blue, //폼의 미리보기글씨 색
                      fontSize: 20.0
                    )
                  )
                ),
                  child: Container( // 컨네이너로 하단을 잡고 컬럼 3개로 구성
                    padding: EdgeInsets.all(20),
                    child: Column(
                      children:<Widget> [
                        TextFormField(  //
                          decoration: InputDecoration(  //아이디를 적어주세요
                            labelText: 'Email 주소를 적어주세요',
                            hintText:'예)adg@dkfek.com',
                            hintStyle: TextStyle(
                              fontSize: 8,
                            )
                          ),
                          keyboardType: TextInputType.emailAddress,
                        ),
                        TextField(   //데코레이션을 가져온다
                          decoration: InputDecoration(
                              labelText: '비밀번호'
                          ),
                          keyboardType: TextInputType.text,
                          obscureText: true,
                        ),
                        SizedBox(height: 40.0),
                        ButtonTheme(  //버튼의 외형을 설정 할수있다
                          minWidth: 100.0,

                            height: 50.0,
                            child: RaisedButton(
                              color: Colors.orangeAccent,
                                child: Icon(  //글자뿐만 아니라 아이콘도 입력가능
                                  Icons.arrow_forward,
                                  size: 35,
                                ),
                                onPressed: (){




class LogIn extends StatefulWidget {
  @override
  _LogInState createState() => _LogInState();
}

class _LogInState extends State<LogIn> {  //alt enter stf 로 바꾼다

  TextEditingController controller=TextEditingController(); // 텍스트필드 에서 data 를 가져올수있음
  TextEditingController controller2=TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Log in'),
        backgroundColor: Colors.redAccent,
        centerTitle: true,
        leading: IconButton(  // 앱바 좌측 정령
            icon: Icon(Icons.menu),
            onPressed: (){}
        ),
        actions: <Widget>[  //앱바 오른쪽 정령
          IconButton(
              icon: Icon(Icons.search),
              onPressed: (){}
          )
        ],
      ),
      body: Builder( //이것이있어야 토스트 페이지 이동이 가능하다
        builder:(context) {  // page 이동을 위해서 context 값을 받아야함  동영상 18 19
          return GestureDetector(  // 키보드를 없에기위해서 사용자가 누르는 것을 인식하는 위젯
            onTap: () { // key보드는 focus 받고있다  모든 범위에 focusscope 를 해제한다
              FocusScope.of(context).unfocus();
            },
              child: SingleChildScrollView(  //context 값을 받기 위해선 빌더의 리턴된 위젯 안에 있어야 한다  //자판기 사용시 화면이 밀릴경우 사용한다
              child: Column(  //전체적인 화면 구성을 크게 2개의 컬럼으로 구성

                children:<Widget> [
                  Padding(padding: EdgeInsets.only(top: 50)), //상단에서 50px 떨어짐
                  Center(  // 이미지로 상단을 구성 하고

                    child: Image(
                      image: AssetImage('image/chef.gif'),
                      width:170 ,
                      height: 190,
                    ),
                  ),
                  Form( //하단은 폼 으로 잡고
                    child:Theme(  // 폼의 형식을 설정함
                        data: ThemeData(
                            primaryColor: Colors.orangeAccent,   //text 입력줄 아래 색 선택시 보여줌
                            inputDecorationTheme: InputDecorationTheme(
                                labelStyle: TextStyle(
                                    color: Colors.blue, //폼의 미리보기글씨 색
                                    fontSize: 20.0
                                )
                            )
                        ),
                        child: Container( // 컨네이너로 하단을 잡고 컬럼 3개로 구성
                          padding: EdgeInsets.all(20),
                          child: Column(
                            children:<Widget> [
                              TextFormField(
                                controller: controller,
                                decoration: InputDecoration(  //아이디를 적어주세요
                                    labelText: 'dice 적어주세요',
                                    hintText:'예)dice',
                                    hintStyle: TextStyle(
                                      fontSize: 8,
                                    )
                                ),
                                keyboardType: TextInputType.emailAddress,
                              ),
                              TextField(   //데코레이션을 가져온다
                                controller: controller2,
                                decoration: InputDecoration(
                                    labelText: '비밀번호',
                                  hintText:'1234',
                                ),
                                keyboardType: TextInputType.text,
                                obscureText: true,
                              ),
                              SizedBox(height: 40.0),
                              ButtonTheme(  //버튼의 외형을 설정 할수있다
                                minWidth: 100.0,

                                height: 50.0,
                                child: RaisedButton(
                                    color: Colors.orangeAccent,
                                    child: Icon(  //글자뿐만 아니라 아이콘도 입력가능
                                      Icons.arrow_forward,
                                      size: 35,
                                    ),
                                    onPressed: (){

                                      if(controller.text=='dice'&& controller2.text=='1234'){

                                        Navigator.push(context, //builder 의 context 가있어야한다!!
                                            MaterialPageRoute(builder:(context)=>Dice()) //builder 안전장치
                                        );
                                      }else if(controller.text=='dice'&& controller2.text!='1234'){
                                        
                                        showSnackBar2(context);                                   
                                      }else if(controller.text!='dice'&& controller2.text=='1234'){
                                        showSnackBar3(context);
                                      }else{
                                        showSnackBar(context);
                                      }

void showSnackBar(BuildContext context){
  Scaffold.of(context).showSnackBar(  //snackbar는 scaffold 의 정확한 context 를 참조해서
    SnackBar(content:                 //그곳에 snackbar 를 그린다
    Text('로그인 정보를 다시확인하세요 ',
    textAlign: TextAlign.center,),
    duration: Duration(seconds: 2),
    backgroundColor: Colors.blue,





    Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor:Colors.redAccent,
      appBar: AppBar(
        backgroundColor: Colors.redAccent,
        title: Text('Dice Game'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children:<Widget> [
            Padding(
              padding: EdgeInsets.all(32.0),
              child: Row( // expanded 때문에 화면이 꽉참 그래서 패딩으로 사이즈를 주면서 row 패딩으로 감쌈
                children:<Widget> [
                  Expanded(// 이미지를 끝가지 확장
                    //flex: 1,//비율애 따라 이미지 크기를 지정한다
                    child: Image.asset('image/dice$leftDice.png')), //같다 Image(image: AssetImage('image/dice1.png'),

                  SizedBox(                                         //주사위 사진이 파일명과 숫자명이 같으므로 랜덤함수 변수로 지정해준다
                    width: 20.0,
                  ),

                  Expanded(
                    //flex: 3,
                      child: Image.asset('image/dice$rightDice.png')),
                ],
              ),
            ),

            SizedBox(
              height: 60.0,
            ),

            ButtonTheme(
              minWidth: 100.0, //88 이상
              height: 60.0,  // 36 이상 줘야 에러가 없다
              child: RaisedButton(
                child: Icon(Icons.play_arrow,
                      color: Colors.white,
                      size: 40.0,
                     ),
                  color: Colors.orangeAccent,
                  onPressed: (){
                  setState(() {  // 변수의 변함을 인식한다
                    leftDice=Random().nextInt(6)+1; // 렌덤값을 변수에 입력한다 nextInt(x) 0~x 까지이다
                    rightDice=Random().nextInt(6)+1;
                  });
                  showToast(
                    "Left dice: {$leftDice} ,Right dice:{$rightDice}");






void showToast(String message){
  Fluttertoast.showToast(msg: message,
  backgroundColor: Colors.white,
  toastLength: Toast.LENGTH_SHORT,
  gravity: ToastGravity.BOTTOM);


한가지만 순서대로 하는방식을 Synchronous
전부 순서없이 하는것을 Asyncronous 방식  -> 기다려 await 가나옴





void main(){
  showData();
}
 
void showData() async{
startTask();
String account= await accessData();  // aceessData 함수 실행할때까지 기다려라
fetchData(account);
}

void startTask(){
  String info1='요청 수행 시작';
  print(info1);
}

Future<String> accessData() async{   //영수증 앞으로 실체를 가지게 될것이다
                                      //async 는 중가로앞에 위치해야한다 awite 함수를 쓸수있따
  String account;                     // Future 클래스는 비동기 작업을 할때 사용 일정 시간뒤 데이터나 에러 반환
                                      // async 클래스는 await 메서드를 가지고 있음
                                      
  Duration time = Duration(seconds: 3);  // 지연을 한다
   if(time.inSeconds>2){
    await Future.delayed(time ,(){   //await 로 서언된 메서드는 응답이 처리할때까지 대기한다
      account='8,500 만원';
      print(account);
    });
  }
return account;
  //  sleep(time);                          // 들어온 변수 값을 시간동안 멈춘다
  //  String info2='데이터에 접속중';  // 코드가 진행되다가 지연이 생기던 아니던 순서대로  진행되는게
  // print(info2);                     //  synchronous 방식
}

void fetchData(String account){
  String info3='잔액은 $account 입니다';
  print(info3);


for in loop  for(var x in List) {method(x)}
forEach     list.forEach((x){method(x);});
           
다트는 싱글 스레드 이다 한가지만 하고 그다음한다
dart s는 3가지로 일한다
1 frist in first out fifo  MicroTask(event queue) 와 event 준비
2 main 함수 실행
3 event loop  실행 =>이때 Future Stream

asysnc method
 method 통한 결과물은 Future
 Await 만날때까지  synchronous 처리
await 키워드를 만나면 future 완료될때까지대기
future 가 완료되자마자 다음 코드 실행 



event loop  flutter 시작 순간 isolate 


oid main(){
  showData();
}


void showData() async{

startTask();
String account= await accessData();  // aceessData 함수 실행할때까지 기다려라
fetchData(account);
}

void startTask(){
  String info1='요청 수행 시작';
  print(info1);
}

Future<String> accessData() async{   //영수증 앞으로 실체를 가지게 될것이다
                                      //async 는 중가로앞에 위치해야한다 awite 함수를 쓸수있따
  String account;                     // Future 클래스는 비동기 작업을 할때 사용 일정 시간뒤 데이터나 에러 반환
                                      // async 클래스는 await 메서드를 가지고 있음

  Duration time = Duration(seconds: 3);  // 지연을 한다
   if(time.inSeconds>2){
    await Future.delayed(time ,(){   //await 로 서언된 메서드는 응답이 처리할때까지 대기한다
      account='8,500 만원';
      print(account);
    });
  }
return account;
  //  sleep(time);                          // 들어온 변수 값을 시간동안 멈춘다
  //  String info2='데이터에 접속중';  // 코드가 진행되다가 지연이 생기던 아니던 순서대로  진행되는게
  // print(info2);                     //  synchronous 방식
}

void fetchData(String account){
  String info3='잔액은 $account 입니다';
  print(info3);


  void main() async{

  print('order...');
  print( await orderMsg());

}                                     //async 를 만나면 await 까지 비동기로간다

Future<String> orderMsg() async{
 
  var order = await fUserOrder();  //비동기방식 즉 기다려야함 
  
  return 'order is $order';        //동기 방식으로 실행되고있음 
}
                                 //async 는 Future 를 대신하는게 아님 다트에게 비동                                   기방식이야 알려주고 미래에 어느시점에 올 값을 기다리                                   는거야 

Future<String> fUserOrder(){


return Future.delayed(
      Duration(seconds:2),
() =>'Large latte',





    RaisedButton(
                onPressed: () {
                  futureTest();
                },
                child: Padding(
                  padding: EdgeInsets.all(8),
                  child: Text(
                    'Future test',
                    style: TextStyle(
                        fontSize: 20.0
                    ),

                  ),
                ),
              ),
              SizedBox(
                height: 20.0,
              ),
              Text(
                result,
                style: TextStyle(
                  fontSize: 20.0,
                  color: Colors.redAccent,
                ),
              ),
              Divider(
               height: 20,
               thickness: 2.0,
             ),
              FutureBuilder(                 // 데이터가 오는걸 시각적으로 표시할때
                                              // future builder initialdata 3개가 와야함함
                  future: myFuture(),       // return Future value 필요함
                  builder:(context,snapshot){  // 특정시점 데이터를 복사 보관함
                    if(snapshot.connectionState==ConnectionState.done){ //snapshot 에 데이터가 복사해서 보관하는지 확인작업
                                                                      //none 없을때 waiting 기다릴때 done 완료 됬을때
                      return Text(snapshot.data,
                      style: TextStyle(
                        fontSize: 20.0,
                        color: Colors.redAccent,
                      ),
                      );
                    }
                    return CircularProgressIndicator();

            

  Future<void> futureTest() async{


    await Future.delayed(Duration(seconds: 3))
        .then((value) {
                    print('here comes first1');     // 1번
       setState(() {
        this.result = 'The data is fetched';      //2번
        print(result);
                    print('here comes first2');   //3번

        // void futureTest() {                            // here com 나오고 다음 data fetch 나온다
  //   Future.delayed(Duration(seconds: 3))
  //       .then((value) {
  //     setState(() {
  //       this.result = 'The data is fetched';
      });
    });
    print('here comes first');                 //4
    print('here comes first3');               //5
  }

  Future<String> myFuture() async{
    await Future.delayed(Duration(seconds: 2));
        return 'anotther future compl';
  }
}






Stataful Widget life 

page move
initialRoute  /  route { '/' : (context)}=>funtion()
pushNamed(content,'/')



class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
     initialRoute: '/',                    
      routes: {
        '/' :(context)=>ScreenA(),
        '/b':(context)=>ScreenB(),
        '/c':(context)=>ScreenC(),



class ScreenA extends StatefulWidget {


  @override
  _ScreenAState createState() => _ScreenAState();
}

class _ScreenAState extends State<ScreenA> {
  @override
  void initState() {                      //app 을 실행할때시작
    // TODO: implement initState
    super.initState();
    print('initState is Called');
  }



  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar:AppBar(
        title: Text('ScreenA'),
        centerTitle: true,
        backgroundColor: Colors.blue,
      ),
      body:Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children:<Widget> [
            RaisedButton(
              color: Colors.redAccent,
                child: Text(
                  'b 화면으로'
                ),
                onPressed: () {
                  Navigator.pushNamed(context, '/b');
                }
  
  class ScreenB extends StatefulWidget {
  @override
  _ScreenBState createState() => _ScreenBState();
}

class _ScreenBState extends State<ScreenB> {

   @override
  void dispose() {                      // route 가 사라질때 실행 
    // TODO: implement dispose
    super.dispose();
    print ('dispose is called');
  }



  @override
  Widget build(BuildContext context) {
    print('bulid is called');                    // 빌드할때시작
    return Scaffold(
      appBar: AppBar(
        title: Text('ScreenB'),
        backgroundColor: Colors.blue,

      ),
      body: Center(
        child: Text('ScreenB',
        style: TextStyle(
          fontSize: 24.0




APi

import 'package:geolocator/geolocator.dart';


class Loading extends StatefulWidget {
  @override
  _LoadingState createState() => _LoadingState();
}




class _LoadingState extends State<Loading> {

  void getLocation()async{
    print('ok');
    Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high);  // dot 전용 위치기반 앱 실행
    // geolocator install pubspec. 설정  후  임포트  app main manifac  에서 설정 후실행해야함 

 print(position);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: RaisedButton(
          onPressed: (){
            getLocation();
          },
          child: Text(
            'get my location',
            style: TextStyle(
              color: Colors.white,



SvgPicture

IconButton(
          onPressed: () {},
          icon: SvgPicture.asset(   // 아이콘 버튼 데신 svg 란 그림을 넣을수있음 크기조절은 width
            'assets/svg/bell.svg',
            width: 22.0,
          ),

pubdev 에서 flutter_svg 다운  
flutter_svg: ^0.19.3  
import 'package:flutter_svg/flutter_svg.dart';

보통 assets 설정으로 가서 assets/img  assets/svg  로 설정해준다 



ThemeData

MaterialApp(
      title: 'flutter app',
      theme: ThemeData(
        primaryColor: Colors.white,     appbar 에서 배경 지정 가능하나 material에서도 가능하다




Map > List 

class _HomeState extends State<Home> {
  List<Map<String, String>> datas = [];  // 맵형 데이터를 리스트로 받아들인다

   void initState() {
    super.initState();
    datas = [
      {
        "cid": "1",
        "image": "assets/images/ara-1.jpg",
        "title": "네메시스 축구화275",
        "location": "제주 제주시 아라동",
        "price": "30000",
        "likes": "2"
      },


GestureDetector


AppBar(
      elevation: 1.0,
      title: GestureDetector(                   // 제스쳐 디텍더 를 사용하면 여러함수를 쓸수있다
        onTap: () {print('click');
        onLongPress: () {
          print('long click');
   

 NumberFormat  

final oCcy = new NumberFormat( "#,###", "ko_KR");          // 스트링을 원화 포멧으로 바꿔준다 import 'package:intl/intl.dart';
  String calculStringToWon(String price) {
    return "${oCcy.format(int.parse(price))} 원";          //int.parse() 인트로 바꿔준다
  }





ListView.separated 


 Widget _bodyWidget() {
    return ListView.separated(    // 3가지 itemCount,separatorBuilder, itemBuilder 꼭와야한다
                            padding:
                          const EdgeInsets.symmetric(horizontal: 10), //전체 패딩 하는이유는 아래선도 포함해야함

      itemCount: 10,

      separatorBuilder: (BuildContext context, int index) {  // 사이간격에 라인을 나눠준다
                        
                        return Container(
                          height: 1,
                          color: Colors.black.withOpacity(0.5),
                          // color: Color(0xff999999)

      itemBuilder: (BuildContext context, int index) {
                       
                        return Padding(

     padding: const EdgeInsets.symmetric(vertical: 10), //이미지 상하 패딩
                          
                          
                          child: Container(
                              child: Row( children: [


      ClipRRect(   // 외우자 모르갯다
                                 
      borderRadius: BorderRadius.all(Radius.circular(10.0)), // 이미지 모서리 둥굴기설정
      
      
      child: Image.asset(datas[index]["image"],  //데이터에서 이미지 뽑아오는법 
                                   
                                   
                                    width: 70,
                                    height: 70,
                                  )),
                              // SizedBox(  이미지와 텍스트 사이
                              //   width: 10,
                              // ),
    
    Expanded(                      // 위에 ClipRRect 를 제외한 나머지 값을 전부 쓴다
                                
                                child: Container( // 부모의 싸이즈를 지정한다
                                  padding: EdgeInsets.only(left: 10),
                                  
                                  height: 80,
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
      
      Text(datas[index]['title'],overflow: TextOverflow.ellipsis,   //text 가 넘어가면 줄바꿈을 막아줌
                                        
                                     
                                      Text(datas[index]['location']),
                                      Text(calculStringToWon(datas[index]['price']),

  style: TextStyle(fontWeight: FontWeight.w800),  // 글자 두깨 늘리는법 
                                     

                                      Expanded(
                                        //확장은 부모의 싸이즈 따라간다
                                        child: Container(
                                          child: Row(
                                            mainAxisAlignment: MainAxisAlignment.end,
                                            crossAxisAlignment: CrossAxisAlignment.end,
                                            children: [
                                              SvgPicture.asset(
                                                'assets/svg/heart_off.svg',
                                                width: 13,
                                                height: 13,
                                              ),
                                              SizedBox(
                                                width: 5,
                                              ),
                                              Text(datas[index]['likes']),



BottomNavigationBar

Scaffold의 body에 위젯 List[index] 형태로 보여질 위젯을 정해주고 
탭을 선택할 때 index가 변화하도록 하는 방법이다.

 BottomNavigationBar는 currentIndex라는 선택 탭의 번호를 
 지정하는 속성을 가지고 있는데, 이 속성의 값은 탭의 선택에 따라 
 자동으로 변경되는 것이 아니라 아래의 예제처럼 onTap을 정의해주어야한다.

onTap에서 screenIndex를 value로 변경하면 body의 List 요소와 
탭이 함께 변경되어 우리가 아는 것처럼 하단 탭 부분과 화면이 바뀌게 된다.


class _HomeState extends State<Home> {
  List<Map<String, String>> datas = [];

  int _currentPageIndex;

  BottomNavigationBarItem _bottomNavigationBarItem(
    String iconName, String label) {
    
    return BottomNavigationBarItem(

        activeIcon: Padding(  /활성화될때 나타나는 아이콘
          padding: const EdgeInsets.only(bottom: 5.0), //바텀 내비 라벨 과 svg 사이간격 올림
          child: SvgPicture.asset(
            'assets/svg/${label}_on.svg', //색이채워짐
            width: 22.0,
            height: 22.0,
          ),
        ),


        icon: Padding(
          padding: const EdgeInsets.only(bottom: 5.0), //바텀 내비 라벨 과 svg 사이간격 올림
          child: SvgPicture.asset(
            'assets/svg/${label}_off.svg',
            width: 22,
            height: 22,
          ),
        ),
        label: iconName);
  }

  
  
  Widget _bottomNavigationBarWidget() {
    return BottomNavigationBar(
        type: BottomNavigationBarType.fixed, //라벨과 아이콘 정렬해준다
        onTap: (int index) {
          // 홈이나 동내생활등에 페이지를 지정해준다 items 순서로 0.1.2
          print(index);
          setState(() {
            _currentPageIndex = index;
          });
        },
        currentIndex: _currentPageIndex, // 현제 인덱스갑 설정
        selectedFontSize: 15, // laval 크기선택
        selectedItemColor: Colors.black, //현제 페이지 의 iconname 값이 강조됨
        // selectedLabelStyle: TextStyle(color: Colors.black),
        items: [
          _bottomNavigationBarItem('동네 생활', 'notes'),
          _bottomNavigationBarItem('홈', 'home'),
          _bottomNavigationBarItem('내 근처', 'location'),
          _bottomNavigationBarItem('채팅', 'chat'),
          _bottomNavigationBarItem('나의 당근', 'user'),
        ]);
  }

appbar 

String currentLocation;
  
final Map<String, String> locationTypeToString = {
    "ara": "아라동",
    "ora": "오라동",
    "donam": "도남동"
  };


   PopupMenuButton<String>(
          offset: Offset(0, 20), // 상자가나오는데  위치이동시킴
          shape: ShapeBorder.lerp( //테두리설정
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(10.0)),
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(10.0)),
              1),
          onSelected: (String where) {
            
            setState(() {
              currentLocation = where;
            });
          },
          itemBuilder: (BuildContext context) {
            return [
              PopupMenuItem(
                value: "ara",
                child: Text('아라동'),
              ),
              PopupMenuItem(
                value: "ora",
                child: Text('오라동'),
              ),
              PopupMenuItem(
                value: "donam",
                child: Text('도남동'),
              ),
            ];
          },
          child: Row(children: [
            Text(
              locationTypeToString[currentLocation],
            ),
            Icon(Icons.arrow_drop_down),
          ]),
        ),